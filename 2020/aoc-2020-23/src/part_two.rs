const MOVES: usize = 10_000_000;
const CUPS: usize = 1_000_000;

pub fn solve(input: &[usize]) -> usize {
    let mut cups = init(input, CUPS);
    for _ in 0..MOVES {
        let sel = cups[0];

        let a = cups[sel];
        let b = cups[a];
        let c = cups[b];
        cups[sel] = cups[c];
        cups[0] = cups[c];

        let mut x = sel - 1;
        while x == a || x == b || x == c || x == 0 {
            if x == 0 {
                x = CUPS;
            } else {
                x -= 1;
            }
        }

        let cut = cups[x];
        cups[x] = a;
        cups[c] = cut;
    }

    let a = cups[1];
    let b = cups[a];

    a * b
}

// Using u32 instead of usize would be almost as twice as fast, because
// the data does not fit in the L1/2/3 cache, so it has to go to RAM
// which is slow. By reducing the type width, we can store as twice as
// much data in the CPU cache and would need to fetch 2x less data from RAM
fn init(input: &[usize], len: usize) -> Vec<usize> {
    assert!(input.len() > 0);
    assert!(input.len() <= len);
    /*
       The cup numbers are the array indexes. The values are the next cup
       in the linked list. Thus on one hand we have a linked list without having
       to deal with heap allocation and Rc/RefCell/etc, and on the other -> a
       dictionary, which gives us O(1) access to any node in the linked list.
    */
    let mut nodes = Vec::with_capacity(len + 1);
    for v in 0..len + 1 {
        nodes.push(v + 1)
    }

    for idx in 0..input.len() - 1 {
        let value = input[idx];
        let points_to = input[idx + 1];

        nodes[value] = points_to;
    }

    // The 0 node, points to the currently selected node
    nodes[0] = input[0];

    // The last from the input, points to the first autogenerated cup number
    nodes[input[input.len() - 1]] = if input.len() == len {
        input[0]
    } else {
        input.len() + 1
    };

    if nodes.len() > input.len() + 1 {
        let idx = nodes.len() - 1;
        nodes[idx] = input[0];
    }

    nodes
}
